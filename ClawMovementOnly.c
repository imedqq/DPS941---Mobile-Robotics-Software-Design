#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawLimit,      sensorPotentiometer)
#pragma config(Sensor, in2,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in4,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl6,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393HighSpeed_HBridge, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port2,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393HighSpeed_HBridge, PIDControl, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                         - Wait for Dark -                                          *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs the robot to wait until the lights around it go down to move forward for   *|
|*  1.5 seconds.  There is a two second pause at the beginning of the program.                        *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" mode, but may not be needed for all robot configurations.                       *|
|*    2)  Lighting conditions change from place to place, so the value '200' may need to be changed   *|
|*        to better suit your environment.                                                            *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor  - Port 2     rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor  - Port 3     leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Analog - Port 8     lightSensor         VEX Light Sensor      Mounted facing up                 *|
\*-----------------------------------------------------------------------------------------------4246-**/
int clawPower = 45;
int armPower = 25;
int prevSonar = 0;
void creepForward();
void setPreviousSonar(){
	if (SensorValue[sonarSensor] != -1 && SensorValue[sonarSensor] < 75){
		prevSonar = SensorValue[sonarSensor];
	}
}

void stopMovements(){
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}
void openClaw(){
	wait1Msec(500);
	motor[clawMotor] = clawPower;
	wait1Msec(750);
	motor[clawMotor] = 0;
}

void closeClawObject(bool with){
	if (with){
		creepForward();
		if (SensorValue[sonarSensor] <= 12 && SensorValue[sonarSensor] != -1){
			motor[clawMotor] = -clawPower;
			wait1Msec(600);
			motor[clawMotor] = 0;
		}
	}
	else{
		motor[clawMotor] = -clawPower;
		wait1Msec(600);
		motor[clawMotor] = 0;
	}
}
void closeClaw(){

	motor[clawMotor] = -clawPower;
	wait1Msec(600);
	motor[clawMotor] = 0;
}
void creepForward(){
	motor[leftMotor] = 15;
	motor[rightMotor] = 15;
	while(SensorValue[sonarSensor] <= prevSonar || SensorValue[sonarSensor] != -1){
		setPreviousSonar();
		if (SensorValue[sonarSensor] < 13 && SensorValue[sonarSensor] != -1){
			stopMovements();
			break;
		}
	}
}


void liftArm(){
	while (SensorValue[clawLimit] > 2000){ // claw limit exceeded - dont do anything
		motor[armMotor] = -armPower - 10;
	}
	motor[armMotor] = 0;
}
void lowerArm(){
	while (SensorValue[clawLimit] < 4000){
		motor[armMotor] = armPower;
	}
	motor[armMotor] = 0;
}

void start360Scan(){

	motor[leftMotor] = 25;
	motor[rightMotor] = -25;
	while (prevSonar == 0){
		setPreviousSonar();
	}
	//need break logic to give up on scanning when PIDs tell us we did a ~360 turn.
	stopMovements();
	openClaw();

}

void pivotRight(){
	motor[leftMotor] = 15;
	motor[rightMotor] = -15;
	wait1Msec(1000);
	while( SensorValue[sonarSensor] < prevSonar && SensorValue[sonarSensor] != -1){
		wait1Msec(150);
		setPreviousSonar(); //get new lowest value
	}
	stopMovements();
	creepForward();
}
/*
void pivotLeft(){
motor[leftMotor] = -15;
motor[rightMotor] = 15;
wait1Msec(2000);
while( SensorValue[sonarSensor] < prevSonar && SensorValue[sonarSensor] != -1){
wait1Msec(500);
prevSonar = SensorValue[sonarSensor]; //update prev
}
stopMovements();
creepForward();
}
*/

task main(){
	wait1Msec(1000);
	start360Scan();
	setPreviousSonar();
	wait1Msec(2000);

	pivotRight();

	//pivotLeft();
closeClawObject(true);
		stopMovements();
	liftArm();
	lowerArm();
	openClaw();


}
