#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawLimit,      sensorPotentiometer)
#pragma config(Sensor, in2,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in4,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl6,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393HighSpeed_HBridge, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port2,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393HighSpeed_HBridge, PIDControl, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                         - Wait for Dark -                                          *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs the robot to wait until the lights around it go down to move forward for   *|
|*  1.5 seconds.  There is a two second pause at the beginning of the program.                        *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" mode, but may not be needed for all robot configurations.                       *|
|*    2)  Lighting conditions change from place to place, so the value '200' may need to be changed   *|
|*        to better suit your environment.                                                            *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor  - Port 2     rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor  - Port 3     leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Analog - Port 8     lightSensor         VEX Light Sensor      Mounted facing up                 *|
\*-----------------------------------------------------------------------------------------------4246-**/
int clawPower = 35;
int armPower = 25;
int prevSonar = 9999;
long temp = 0;
int lowestSonar = 9999;
int objectRight = 0;
int objectLeft = 0;
int counter = 0;

void creepForward();
void turnLeft();
void turnRight();

void scanForObject(int i);
int scanArea(int proximity);
void driveTowardObject();

void hugBlackLine();

int motorTarget = 525;
int turningMotorSpeed = 20;
int forwardMotorSpeed = 55; //127 max, 63 half
int THRESHOLDLINE = 2000;
int THRESHOLDBOUND = 300;


void turnLeft(){

	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	wait1Msec(1000);
	moveMotorTarget(rightMotor, motorTarget, turningMotorSpeed, true);
	moveMotorTarget(leftMotor, -motorTarget, -turningMotorSpeed, true);

	while(getMotorTargetCompleted(rightMotor) == false && getMotorTargetCompleted(leftMotor) == false){
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void turnRight(){
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	wait1Msec(1000);
	moveMotorTarget(rightMotor, -motorTarget, -turningMotorSpeed, true);
	moveMotorTarget(leftMotor, motorTarget, turningMotorSpeed, true);

	while(getMotorTargetCompleted(rightMotor) == false && getMotorTargetCompleted(leftMotor) == false){
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}
/*
void GoForward(int target){
	if (target == NULL){
		target = 550;
	}
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	moveMotorTarget(rightMotor, target, forwardMotorSpeed, true);
	moveMotorTarget(leftMotor, target, forwardMotorSpeed, true);
	while(getMotorTargetCompleted(rightMotor) == false && getMotorTargetCompleted(leftMotor) == false){
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}
*/
void GoForwardUntilLine(int target){
	if (target == NULL){
		target = 550000;
	}
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	moveMotorTarget(rightMotor, target, 55, true);
	moveMotorTarget(leftMotor, target, 55, true);
	while(getMotorTargetCompleted(rightMotor) == false && getMotorTargetCompleted(leftMotor) == false){
		//wait for dark line
		if(SensorValue(lineFollowerLEFT)> THRESHOLDLINE || SensorValue(lineFollowerRIGHT)> THRESHOLDLINE){
			//stop at dark line upon sensing
			motor[rightMotor] = 0;
			motor[leftMotor] = 0;
			break;
		}
	}
	hugBlackLine();
}

int leftMotorEncoder = 0;
int rightMotorEncoder = 0;
int motorEncoder = 0;

void hugBlackLine(){
	int threshold = THRESHOLDLINE; //505; //found by taking a reading on both DARK and LIGHT surfaces, adding them together, then dividing by 2
	float objectDistance = 5; // inches, with claw is 7.5inches, object in claw is 4.5inches

	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;

	if(motorEncoder == 0){
		while(SensorValue(sonarSensor) > objectDistance || SensorValue(sonarSensor) == -1){
			// Loop while robot's ultrasonic sensor is further than 20 inches away form an object
			// -1 is the value returned when nothing is in it's visable range

			//RIGHT sensor sees dark
			if(SensorValue(lineFollowerRIGHT) > threshold){
				// counter-steer right
				motor[leftMotor] = turningMotorSpeed; //63;
				motor[rightMotor] = 0;
			}

			//CENTER sensor sees dark
			if(SensorValue(lineFollowerCENTER) > threshold){
				// go straight
				motor[leftMotor] = turningMotorSpeed; //63;
				motor[rightMotor] = turningMotorSpeed; //63;
			}

			//LEFT sensor sees dark
			if(SensorValue(lineFollowerLEFT) > threshold){
				// counter-steer left
				motor[leftMotor] = 0;
				motor[rightMotor] = turningMotorSpeed; //63;
			}
		}
		motorEncoder = (nMotorEncoder[leftMotor]+nMotorEncoder[rightMotor])/2;
	}else if(motorEncoder < 0){
		while(true){
			// Loop until robot is at end of the line for dropping object

			//RIGHT sensor sees dark
			if(SensorValue(lineFollowerRIGHT) > threshold){
				// counter-steer right
				motor[leftMotor] = turningMotorSpeed; //63;
				motor[rightMotor] = 0;
			}

			//CENTER sensor sees dark
			if(SensorValue(lineFollowerCENTER) > threshold){
				// go straight
				motor[leftMotor] = turningMotorSpeed; //63;
				motor[rightMotor] = turningMotorSpeed; //63;
			}

			//LEFT sensor sees dark
			if(SensorValue(lineFollowerLEFT) > threshold){
				// counter-steer left
				motor[leftMotor] = 0;
				motor[rightMotor] = turningMotorSpeed; //63;
			}
		}

	}else{
		while(nMotorEncoder[leftMotor] <= motorEncoder || nMotorEncoder[rightMotor] <= motorEncoder){
			// recorded distance taken from point where first touch black line #1

			//RIGHT sensor sees dark
			if(SensorValue(lineFollowerRIGHT) > threshold){
				// counter-steer right
				motor[leftMotor] = turningMotorSpeed; //63;
				motor[rightMotor] = 0;
			}

			//CENTER sensor sees dark
			if(SensorValue(lineFollowerCENTER) > threshold){
				// go straight
				motor[leftMotor] = turningMotorSpeed; //63;
				motor[rightMotor] = turningMotorSpeed; //63;
			}

			//LEFT sensor sees dark
			if(SensorValue(lineFollowerLEFT) > threshold){
				// counter-steer left
				motor[leftMotor] = 0;
				motor[rightMotor] = turningMotorSpeed; //63;
			}
		}
		motorEncoder = 0;
	}

	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
}

int setSonarDistance(int range){
	if (SensorValue[sonarSensor] != -1 && SensorValue[sonarSensor] < range){
		return SensorValue[sonarSensor];
	}
	return -1;
}


void setPreviousSonar(long i){
	if (i != -1 && i < 45){
		lowestSonar = i;
	}
}

void stopMovements(){
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}


void openClaw(){
	wait1Msec(500);
	motor[clawMotor] = clawPower;
	wait1Msec(550);
	motor[clawMotor] = 0;
}

void closeClawObject(bool with){
	if (with){
		creepForward();
		if (SensorValue[sonarSensor] <= 12 && SensorValue[sonarSensor] != -1){
			motor[clawMotor] = -clawPower;
			wait1Msec(600);
			motor[clawMotor] = 0;
		}
	}
	else{
		motor[clawMotor] = -clawPower;
		wait1Msec(600);
		motor[clawMotor] = 0;
	}
}

void closeClaw(){

	motor[clawMotor] = -clawPower;
	wait1Msec(600);
	motor[clawMotor] = 0;
}


void creepForward(){
	motor[leftMotor] = 15;
	motor[rightMotor] = 15;
	while(SensorValue[sonarSensor] <= prevSonar || SensorValue[sonarSensor] != -1){
		//setPreviousSonar(0);
		if (SensorValue[sonarSensor] < 13 || SensorValue[sonarSensor] == -1){ //stop if we are at object or lost sight of it
			stopMovements();
			break;
		}
	}
}


void liftArm(){
	while (SensorValue[clawLimit] > 2000){ // claw limit exceeded - dont do anything
		motor[armMotor] = -armPower - 10;
	}
	motor[armMotor] = 0;
}
void lowerArm(){
	while (SensorValue[clawLimit] < 4000){
		motor[armMotor] = armPower;
	}
	motor[armMotor] = 0;
}



//Idea behind this is to first reach the first line and stay perpendicular to it. After that
//this function will be called in order to scan a 180 degree area from the left all the way to the right of the robot.
//We then store the motor encoders and distance of the closest object and then use the motor encoders to orient the robot
//towards object.

int scanArea(int proximity) {
	if (lowestSonar < 0) {
		lowestSonar = 9999;
	}
	wait1Msec(200);
	//reset motor encoders
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;

	//turn to the right by roughly 90 degrees. (calculated from encoders)
	int i = 0;
	while (i == 0){
		motor[leftMotor] = 15;
		motor[rightMotor] = -15;

		if (SensorValue[sonarSensor] > 0 && SensorValue[sonarSensor] < lowestSonar) {
			lowestSonar = SensorValue[sonarSensor];
			objectRight = getMotorEncoder(rightMotor);
			objectLeft = getMotorEncoder(leftMotor);
		}

		if(getMotorEncoder(leftMotor) > (500 / proximity) || getMotorEncoder(rightMotor) < (-500 / proximity)){
			i = 1;
		}
	}
	stopMovements();
	wait1Msec(200);
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;

	bool end = false;
	//scan 180 degrees while turning left to find the closest object in the scanned area, and save the information of the object
	while (end == false) {
		motor[leftMotor] = -15;
		motor[rightMotor] = 15;

		if (SensorValue[sonarSensor] > 0 && SensorValue[sonarSensor] < lowestSonar) {
			lowestSonar = SensorValue[sonarSensor];
			objectRight = getMotorEncoder(rightMotor);
			objectLeft = getMotorEncoder(leftMotor);
		}

		if (getMotorEncoder(rightMotor) >= (1000 / proximity)) {
			end = true;
		}
	}
		nMotorEncoder[leftMotor] = 0;
		nMotorEncoder[rightMotor] = 0;

		//turn right to point directly towards the closest object
		int n = 0;
		while (n == 0){
		motor[leftMotor] = 15;
		motor[rightMotor] = -15;
		if(getMotorEncoder(leftMotor) > ((980 / proximity) - (-objectLeft))){
			n = 1;
		}
		}
		stopMovements();
		wait1Msec(200);
		/*if (lowestSonar != -1) {
		driveTowardObject();
	} else {
		lowestSonar = 9999;
		scanArea(1);
	}*/
		return lowestSonar;
}

void scanForObject(int i) {
	waitUntil(scanArea(i) != -1);
	driveTowardObject();
}

//After detecting the object and turning to face it, drive towards the object
void driveTowardObject(){
	int i = 1;
	while(i){
		motor[leftMotor] = 10;
		motor[rightMotor] = 10;
		if(SensorValue[sonarSensor] >= 12 && SensorValue[sonarSensor] < 13){
			i = 0;
		} else if (SensorValue[sonarSensor] == -1 && lowestSonar != 9999) {
			scanForObject(2);
		}
	}
	stopMovements();
	//trackObject();
}



task main(){
	//wait1Msec(1000);
	//start360Scan();
	//setPreviousSonar();
	//wait1Msec(2000);

	//pivotRight();

	//pivotLeft();
//	closeClawObject(true);
	//stopMovements();
	//liftArm();
//	lowerArm();
//	openClaw();

//Our new logic
	scanForObject(1);
}
