#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawLimit,      sensorPotentiometer)
#pragma config(Sensor, in2,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in4,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl6,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393HighSpeed_HBridge, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port2,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393HighSpeed_HBridge, PIDControl, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                         - Wait for Dark -                                          *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs the robot to wait until the lights around it go down to move forward for   *|
|*  1.5 seconds.  There is a two second pause at the beginning of the program.                        *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" mode, but may not be needed for all robot configurations.                       *|
|*    2)  Lighting conditions change from place to place, so the value '200' may need to be changed   *|
|*        to better suit your environment.                                                            *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor  - Port 2     rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor  - Port 3     leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Analog - Port 8     lightSensor         VEX Light Sensor      Mounted facing up                 *|
\*-----------------------------------------------------------------------------------------------4246-**/
int clawPower = 35;
int armPower = 25;
int prevSonar = 0;

int lowestSonar = 9999;
int objectRight = 0;
int objectLeft = 0;
bool end = false;

void creepForward();
void pivotLeft();
void pivotRight();
void trackObject();

void driveTowardObject();

int setSonarDistance(int range){
	if (SensorValue[sonarSensor] != -1 && SensorValue[sonarSensor] < range){
		return SensorValue[sonarSensor];
	}
	return -1;
}


void setPreviousSonar(){
	if (SensorValue[sonarSensor] != -1 && SensorValue[sonarSensor] < 45){
		prevSonar = SensorValue[sonarSensor];
	}
}

void stopMovements(){
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}


void openClaw(){
	wait1Msec(500);
	motor[clawMotor] = clawPower;
	wait1Msec(550);
	motor[clawMotor] = 0;
}

void closeClawObject(bool with){
	if (with){
		creepForward();
		if (SensorValue[sonarSensor] <= 12 && SensorValue[sonarSensor] != -1){
			motor[clawMotor] = -clawPower;
			wait1Msec(600);
			motor[clawMotor] = 0;
		}
	}
	else{
		motor[clawMotor] = -clawPower;
		wait1Msec(600);
		motor[clawMotor] = 0;
	}
}

void closeClaw(){

	motor[clawMotor] = -clawPower;
	wait1Msec(600);
	motor[clawMotor] = 0;
}


void creepForward(){
	motor[leftMotor] = 15;
	motor[rightMotor] = 15;
	while(SensorValue[sonarSensor] <= prevSonar || SensorValue[sonarSensor] != -1){
		setPreviousSonar();
		if (SensorValue[sonarSensor] < 13 || SensorValue[sonarSensor] == -1){ //stop if we are at object or lost sight of it
			stopMovements();
			break;
		}
	}
}


void liftArm(){
	while (SensorValue[clawLimit] > 2000){ // claw limit exceeded - dont do anything
		motor[armMotor] = -armPower - 10;
	}
	motor[armMotor] = 0;
}
void lowerArm(){
	while (SensorValue[clawLimit] < 4000){
		motor[armMotor] = armPower;
	}
	motor[armMotor] = 0;
}

void start360Scan(){ //pick up anything on the radar
	prevSonar = 0; // reset sonar
	openClaw();// ensure claw is open
	motor[leftMotor] = 25;
	motor[rightMotor] = -25;
	while (prevSonar == 0){
		setPreviousSonar();
	}
	//need break logic to give up on scanning when PIDs tell us we did a ~360 turn.
	stopMovements();
	trackObject();


}
void trackObject(){
	int rightDistance = -1;
	int leftDistance = -1;
	int centerDistance = -1;

	centerDistance = prevSonar; //reference point set
	//Go check right side
	motor[leftMotor] = 10;
	motor[rightMotor] = -10;
	wait1Msec(900);
	stopMovements();
	rightDistance = setSonarDistance(20); //setSonarDistance(45);
//Right side recorded

	//Go to center reference point
	motor[leftMotor] = -10;
	motor[rightMotor] = 10;
	wait1Msec(900);
//	waitUntil(SensorValue[sonarSensor] == centerDistance);
	stopMovements();
	//returned to center

	//go check left side
	motor[leftMotor] = -10;
	motor[rightMotor] = 10;
	wait1Msec(900);
	stopMovements();
	leftDistance = setSonarDistance(20); //(45);
	//left side recorded
	//Go back to center reference point
	motor[leftMotor] = 10;
	motor[rightMotor] = -10;
	wait1Msec(900);
	//waitUntil(SensorValue[sonarSensor] == centerDistance);
	stopMovements();
	//Go back to center again.
	//Which one was less? creep to that side
	if (centerDistance < rightDistance && centerDistance < leftDistance){
		//We are already on the right track
	}
	else if (leftDistance < rightDistance){
		pivotLeft();
	}
	else {
		pivotRight();
	}

}

void pivotRight(){ //hone in on object
	motor[leftMotor] = 15;
	motor[rightMotor] = -15;
	wait1Msec(1000);
	while( SensorValue[sonarSensor] < prevSonar && SensorValue[sonarSensor] != -1){
		wait1Msec(150);
		setPreviousSonar(); //get new lowest value
	}
	stopMovements();
	creepForward();
}

void pivotLeft(){
	motor[leftMotor] = -15;
	motor[rightMotor] = 15;
	wait1Msec(1000);
	while( SensorValue[sonarSensor] < prevSonar && SensorValue[sonarSensor] != -1){
		wait1Msec(150);
			setPreviousSonar(); //get new lowest value
	}
	stopMovements();
	creepForward();
}

//Idea behind this is to first reach the first line and stay perpendicular to it. After that
//this function will be called in order to scan a 180 degree area from the left all the way to the right of the robot.
//We then store the motor encoders and distance of the closest object and then use the motor encoders to orient the robot
//towards object.

void scanArea() {
	wait1Msec(200);

	//reset motor encoders
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;

	//turn to the right by roughly 90 degrees. (calculated from encoders)
	int i = 0;
	while (i == 0){
		motor[leftMotor] = 15;
		motor[rightMotor] = -15;
		if(getMotorEncoder(leftMotor) > 500 || getMotorEncoder(rightMotor) < -500){
			i = 1;
		}
	}
	stopMovements();
	wait1Msec(200);
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;

	//scan 180 degrees while turning left to find the closest object in the scanned area, and save the information of the object
	while (end == false) {
		motor[leftMotor] = -15;
		motor[rightMotor] = 15;

		if (SensorValue[sonarSensor] != -1 && SensorValue[sonarSensor] < lowestSonar) {
			lowestSonar = SensorValue[sonarSensor];
			objectRight = getMotorEncoder(rightMotor);
			objectLeft = getMotorEncoder(leftMotor);
		}

		if (getMotorEncoder(rightMotor) >= 1000) {
			end = true;
		}
	}
		nMotorEncoder[leftMotor] = 0;
		nMotorEncoder[rightMotor] = 0;

		//turn right to point directly towards the closest object
		int n = 0;
		while (n == 0){
		motor[leftMotor] = 15;
		motor[rightMotor] = -15;
		if(getMotorEncoder(leftMotor) > (980 - (-objectLeft))){
			n = 1;
		}
		}
		stopMovements();
		wait1Msec(200);
		driveTowardObject();
}

//After detecting the object and turning to face it, drive towards the object
void driveTowardObject(){
	int i = 1;
	while(i){
		motor[leftMotor] = 10;
		motor[rightMotor] = 10;
		if(SensorValue[sonarSensor] <= 20){
			i = 0;
		}
	}
	stopMovements();
	trackObject();
}



task main(){
	//wait1Msec(1000);
	//start360Scan();
	//setPreviousSonar();
	//wait1Msec(2000);

	//pivotRight();

	//pivotLeft();
//	closeClawObject(true);
	//stopMovements();
	//liftArm();
//	lowerArm();
//	openClaw();

//Our new logic
	scanArea();
}
